flowchart TD

  A[Intent: captureRequested (thunk)] --> B[CameraGateway.capture()] ///// after conf by user
  B --> C[PhotoStorageGateway.savePhoto(localUri, ticketId)] ===> localStorage device
  C --> D[RemoteTicketMetaGateway.upsert({captured, localUri, thumbUri})] ===> SERVER / API / fragments
  D --> E{{dispatch photoCaptured}} ///// First step DONE ===> update state by reducer + dispatch next step ( uploadRequested )
  E -->|reducer| S1[State: captured]
  E --> F{{dispatch uploadRequested}}

  %% Upload flow
  F --> G[RemoteTicketMetaGateway.get(ticketId)]
  G --> H{meta.localUri ?}
  H -- non --> I{{dispatch uploadFailed(MISSING_FILE)}} --> Sx1[State: invalid]
  H -- oui --> J[RemoteTicketMetaGateway.patch({uploading})]
  J --> K[TicketUploadGateway.upload(localUri, onProgress)]

  K -->|onProgress(pct)| L{{dispatch uploadProgressed(pct)}}
  L -->|reducer| S2[State: uploading]

  K --> M[RemoteTicketMetaGateway.patch({pending, remoteId})]
  M --> N{{dispatch uploadSucceeded(remoteId)}}
  N -->|reducer| S3[State: pending]

  %% Validation côté serveur (asynchrone)
  O[Serveur traite le ticket] --> P[WS/Socket: validation pushed]
  P --> Q{{dispatch validationReceived({valid, data?, reason?})}}
  Q -->|valid==true| S4[State: validated]
  Q -->|valid==false| Sx2[State: invalid]

  %% Branches d'erreur amont / upload
  B -. échec .-> I2{{dispatch uploadFailed(CAPTURE_OR_SAVE_ERROR)}} --> Sx1
  C -. échec .-> I2
  K -. throw .-> I3{{dispatch uploadFailed(UPLOAD_ERROR)}} --> Sx1
