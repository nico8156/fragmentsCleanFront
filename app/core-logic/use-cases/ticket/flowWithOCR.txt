1) Flowchart opérationnel (du point de vue de l’app)

flowchart TD
A[Capture photo] --> B{Photo OK ?}
B -- Non --> A
B -- Oui --> C[OCR on-device]
C --> D{OCR renvoie du texte ?}
D -- Non --> A
D -- Oui --> E[Créer ticketDraft (id, rawText, status=PENDING_ANALYSIS)]
E --> F[POST /tickets/parse (raw_text, locale)]
F --> G{Réponse}
G -- PARSED_OK --> H[Maj state: status=VERIFIED \n + champs normalisés]
G -- PARSED_PARTIAL --> I[Maj state: status=PARTIAL \n + issues[]]
G -- PARSED_INVALID/ERROR --> J[Maj state: status=INVALID/FAILED]
I --> K{Action user}
K -- Compléter manuellement --> L[Form de complétion]
K -- Rescan ciblé --> A
H --> M[(Persist MMKV)]
I --> M
J --> M

2) Machine à états côté app (tickets)

stateDiagram-v2
[*] --> OCR_RUNNING : après capture
OCR_RUNNING --> PENDING_ANALYSIS : OCR OK (rawText obtenu)
OCR_RUNNING --> FAILED : OCR_FAIL / cancel
PENDING_ANALYSIS --> VERIFIED : PARSED_OK
PENDING_ANALYSIS --> PARTIAL : PARSED_PARTIAL
PENDING_ANALYSIS --> INVALID : PARSED_INVALID
PENDING_ANALYSIS --> FAILED : timeout/retry épuisé
PARTIAL --> PENDING_ANALYSIS : resoumission après correction/rescan
VERIFIED --> [*]
INVALID --> [*]
FAILED --> [*]

3) Séquence front ↔ backend ↔ OpenAI

sequenceDiagram
participant U as User
participant A as App (RN/Expo)
participant OCR as OCR on-device
participant S as Serveur API
participant O as OpenAI (extraction)


U->>A: Capture photo
A->>OCR: RecognizeText(image)
OCR-->>A: raw_text (+meta)
A->>A: Crée ticketDraft(status=PENDING_ANALYSIS)
A->>S: POST /tickets/parse { raw_text, locale }
S->>O: Prompt + Schéma JSON (function-calling)
O-->>S: JSON structuré
S->>S: Validation (SIRET, montant, date)
S-->>A: { status: OK/PARTIAL/INVALID, data|issues }
A->>A: Update state (VERIFIED/PARTIAL/INVALID)
A->>A: Persist MMKV & UI feedback

4) Contrats de données (exemple minimal)

// Ticket draft local
interface TicketDraft {
id: string; // UUID local
status: 'OCR_RUNNING' | 'PENDING_ANALYSIS' | 'PARTIAL' | 'INVALID' | 'FAILED' | 'VERIFIED';
capturedAt: string; // ISO
rawText?: string; // purge après VERIFIED
}


// Réponse serveur
type ParseResponse =
| { status: 'PARSED_OK'; data: TicketVerified }
| { status: 'PARSED_PARTIAL'; issues: string[]; data?: Partial<TicketVerified> }
| { status: 'PARSED_INVALID'; issues: string[] };


interface TicketVerified {
merchant_name: string;
merchant_address?: string;
merchant_siret?: string;
purchase_datetime: string; // ISO
total_amount: number;
currency: 'EUR';
vat_amount?: number;
ticket_number?: string;
confidence: number; // 0..1
}